原子性、可见性:
Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；
与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，
[但是它所能实现的功能也仅是 synchronized 的一部分。]
————————————————

锁（synchronized）提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。
- 互斥：
  [即一次只允许一个线程持有某个特定的锁]，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。
- 可见性：
  要更加复杂一些，[它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的] 
  —— 如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。 

这也是导致线程间数据不可见的本质原因。因此要实现volatile变量的可见性，直接从这方面入手即可。
对volatile变量的写操作与普通变量的主要区别有两点：
修改volatile变量时会强制将修改后的值刷新的主内存中。
修改volatile变量后会导致其他线程工作内存中对应的变量值失效。再读取该变量值的时候就需要重新从读取主内存中的值。



(应用场景)一个知乎网友网上说法：
只存在一个线程在那边修改数据其他线程全在读取的场景或者是类似封装在各种AtomicInteger里，
set的时候加一层cas锁保证一致性，一旦那个值变更了所有线程都能立即感知到数据发生了变化，
因为jvm线程是把上下文从发起者复制了一份去跑的，用这个关键字不会复制而是直接访问该内存，
不存在你改了那个值后不可见的问题，所以常用与和cas锁搭配使用，在写入时通过cas保证事务，
写入后通过共享内存机制保证可见性，比如保证某个对象只被初始化一次就可以这样搞定
